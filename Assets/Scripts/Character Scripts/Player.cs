//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Xml.Serialization;


namespace AssemblyCSharp
{
	public enum Sexes
	{
		Male,
		Female
	}

	[XmlRoot("Character")]
	public class Player
	{
		[XmlElement("Sex")]
		public Sexes Sex
		{
			get;
			set;
		}

		[XmlElement("Name")]
		public string Name
		{
			get;
			set;
		}

//		int Level = 0;
//		int Experience = 0;

		public int baseHealth = 0;
		public int baseMana = 0;

		public int totalHealth = 0;
		public int totalMana = 0;

		// Character Base Stats totals
		[XmlArray("baseAttributes")]
		public List<Attribute> baseAttributes = new List<Attribute>();

		// Character Added Stats totals
		[XmlArray("addedAttributes")]
		public List<Attribute> addedAttributes = new List<Attribute>();

		// Character Stat totals
		[XmlArray("totalAttributes")]
		public List<Attribute> totalAttributes = new List<Attribute>();

		// Rings, Armour, Weapons, Sheilds
		[XmlArray("equippedItems")]
		public List<Item> equippedItems = new List<Item>();

		// Rings, armour, weapons
		[XmlArray("inventory")]
		public List<Item> inventory = new List<Item>();

		// When hit with a weapon with spell. 
		[XmlArray("temporaryEffects")]
		public List<Effect> temporaryEffects = new List<Effect>();

		// 1 for pure race 2 for mixed race
		[XmlArray("races")]
		public List<Race> races = new List<Race>();

		// 1 for specific class 2 for dual class
		[XmlArray("charClasses")]
		public List<CharClass> charClasses = new List<CharClass>();

		public Player()
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="AssemblyCSharp.Character"/> class.
		/// </summary>
		/// <param name="name">Name.</param>
		/// <param name="sex">Sex.</param>
		/// <param name="racesParam">Races parameter.</param>
		/// <param name="charClassesParam">Char classes parameter.</param>
		public Player (string name, Sexes sex, List<Race> racesParam, List<CharClass> charClassesParam)
		{
			Name = name;
			Sex = sex;

			foreach(Race currenRace in racesParam)
			{
				races.Add(currenRace);
			}

			foreach(CharClass currenClass in charClassesParam)
			{
				charClasses.Add(currenClass);
			}

			CalcBaseAttributes();
			CalcAddedAttributes();
			CalcTotalAttributes();
		}

		/// <summary>
		/// Setup the the base attributes.
		/// </summary>
		private void CalcBaseAttributes()
		{
			baseAttributes.Clear();

			// Must be added in the same order as the enum to be able to access them by the enum type
			baseAttributes.Add(new Attribute(AttributeTypes.Strength, 10));
			baseAttributes.Add(new Attribute(AttributeTypes.Dexterity, 10));
			baseAttributes.Add(new Attribute(AttributeTypes.Constitution, 10));
			baseAttributes.Add(new Attribute(AttributeTypes.Intelligence, 10));
			baseAttributes.Add(new Attribute(AttributeTypes.Wisdom, 10));
			baseAttributes.Add(new Attribute(AttributeTypes.Charisma, 10));

			int i = 0;

			// Change base attributes dues to Race and Character class
			// Race effects to base stats
			foreach (Race currentRace in races)
			{
				for(i = 0; i < currentRace.attributeChange.Count; i++)
				{
					Attribute temp = currentRace.attributeChange[i];
					if(!ChangeAttribute(baseAttributes, temp.AttributeType, temp.AttributeLevel))
					{
						baseAttributes.Add(new Attribute(temp.AttributeType, temp.AttributeLevel));
					}
				}
			}
			
			// Class effects to base stats
			foreach (CharClass currentClass in charClasses)
			{
				for(i = 0; i < currentClass.attributeChange.Count; i++)
				{
					Attribute temp = currentClass.attributeChange[i];
					if(!ChangeAttribute(baseAttributes, temp.AttributeType, temp.AttributeLevel))
					{
						baseAttributes.Add(new Attribute(temp.AttributeType, temp.AttributeLevel));
					}
				}
			}
		}


		private void CalcAddedAttributes()
		{
			addedAttributes.Clear();

			// Items being worn like Rings, Armour, Weapons
			foreach(Item currentItem in equippedItems)
			{
				foreach(Effect currentEffect in currentItem.activeEffects)
				{
					if(currentEffect.EffectType != EffectTypes.HealthDrain)
					{
						if(!ChangeAttribute(addedAttributes, currentEffect.AttributeType, currentEffect.EffectValue))
						{
							addedAttributes.Add(new Attribute(currentEffect.AttributeType, currentEffect.EffectValue));
						}
					}
				}
			}
		}


		/// <summary>
		/// Calculates the attribute totals.
		/// </summary>
		private void CalcTotalAttributes()
		{
			totalAttributes.Clear();

			// Add additional attributes
			foreach(Attribute currentAttr in baseAttributes)
			{
				totalAttributes.Add(new Attribute(currentAttr.AttributeType, currentAttr.AttributeLevel));
			}

			// Add base effects to totals
			// Loop round additional effects and add them to the total ability effects.
			foreach(Attribute currentAttr in addedAttributes)
			{
				ChangeAttribute(totalAttributes, currentAttr.AttributeType, currentAttr.AttributeLevel);
			}

			foreach(Effect currentEffect in temporaryEffects)
			{
				ChangeAttribute(totalAttributes, currentEffect.AttributeType, currentEffect.EffectValue);
			}

			CalculateHealthAndMana();
		}

		/// <summary>
		/// Changes the attribute in the specified list.
		/// </summary>
		/// <returns><c>true</c>, if attribute was changed, <c>false</c> otherwise.</returns>
		/// <param name="attrList">Attr list.</param>
		/// <param name="attr">Attr.</param>
		/// <param name="attValue">Att value.</param>
		public bool ChangeAttribute(List<Attribute> attrList, AttributeTypes attr, int attValue)
		{
			bool found = false;

			// Search for the attribute and change it
			foreach(Attribute currentAttr in attrList)
			{
				if(currentAttr.AttributeType == attr)
				{
					currentAttr.Change(attValue);
					found = true;
					break;
				}
			}

			return found;
		}


		/// <summary>
		/// Finds the attribute level from the list.
		/// </summary>
		/// <returns>The attribute level.</returns>
		/// <param name="attrList">Attr list.</param>
		/// <param name="attr">Attr.</param>
		public int FindAttributeLevel(List<Attribute> attrList, AttributeTypes attr)
		{
			int result = 0;

			foreach(Attribute currentAttr in attrList)
			{
				if(currentAttr.AttributeType == attr)
				{
					result = currentAttr.AttributeLevel;
					break;
				}
			}

			return result;
		}

		/// <summary>
		/// Calculates the base health and mana.
		/// </summary>
		private void CalculateHealthAndMana()
		{
			baseHealth = baseAttributes[(int)AttributeTypes.Constitution].AttributeLevel * 10;
			baseMana = baseAttributes[(int)AttributeTypes.Intelligence].AttributeLevel * 10;

			totalHealth = baseHealth;
			totalMana = baseMana;
		}


		/// <summary>
		/// Adds an attribute to the base attributes.
		/// </summary>
		/// <param name="attribute">Attribute.</param>
		public void AddAttribute(Attribute attribute)
		{
			baseAttributes.Add(attribute);
		}

		// Add item to inventory if there is room
		public void PickUpItem(Item item)
		{
			inventory.Add(item);
		}

		// Drop item on the floor
		public Item DropItem(int selectedItemIndex)
		{
			Item dropItem = null;

			if(selectedItemIndex >= 0 && selectedItemIndex < inventory.Count)
			{
				dropItem = inventory[selectedItemIndex];
				inventory.RemoveAt(selectedItemIndex);
			}

			return dropItem;
		}

		// Move selected item to worn items list if there is already an item of thise type move it to the inventory
		public void EquipItem(int selectedItemIndex)
		{
			if(selectedItemIndex >= 0 && selectedItemIndex < inventory.Count)
			{
				Item currentItem = inventory[selectedItemIndex];

				Item currentlyWornItem = null;
				foreach(Item wornItem in equippedItems)
				{
					if(wornItem.Type == currentItem.Type)
					{
						currentlyWornItem = wornItem;
						break;
					}
				}

				if(currentlyWornItem != null)
				{
					// Remove the found item from equipped Items
					equippedItems.Remove(currentlyWornItem);
					inventory.Add(currentlyWornItem);
				}

				// Add it to the list of equipped items.
				equippedItems.Add(currentItem);
				inventory.RemoveAt(selectedItemIndex);

				CalcAddedAttributes();
				CalcTotalAttributes();
			}
		}

		// Move selected item from the worn items list to the inventory
		public void UnEquipItem(int selectedItemIndex)
		{
			if(selectedItemIndex >= 0 && selectedItemIndex < equippedItems.Count)
			{
				Item currentItem = equippedItems[selectedItemIndex];

				equippedItems.RemoveAt(selectedItemIndex);
				inventory.Add(currentItem);

				CalcAddedAttributes();
				CalcTotalAttributes();
			}
		}

		/// <summary>
		/// The character was moved clled from the prefab scripts.
		/// </summary>
		public void CharacterMove()
		{
			// The character was moved.
			// Recalc stat totals after effects have been adjusted
			ReduceHealthDueToEffects();
			ReduceEffectsRounds();
			RemoveTemporaryEffect();
			CalcAddedAttributes();
			CalcTotalAttributes();
		}

		/// <summary>
		/// Reduces the health due to health draining effects like poison, fire, vamparitic
		/// </summary>
		private void ReduceHealthDueToEffects()
		{
			foreach(Effect currentEffect in temporaryEffects)
			{
				if(currentEffect.EffectType == EffectTypes.HealthDrain && currentEffect.Rounds > 0)
				{
					totalHealth -= currentEffect.EffectValue;
				}
			}
		}

		/// <summary>
		/// Adds the temporary effect from magic spell
		/// </summary>
		/// <param name="effectParam">Effect parameter.</param>
		public void AddTemporaryEffect(Effect effectParam)
		{
			bool found = false;

			foreach(Effect currentEffect in temporaryEffects)
			{
				if(currentEffect.EffectType == effectParam.EffectType)
				{
					found = true;
					break;
				}
			}

			if(!found)
			{
				temporaryEffects.Add(new Effect(effectParam.EffectType, effectParam.AttributeType, effectParam.Rounds, effectParam.EffectValue));
			}

			CalcTotalAttributes();
		}

		/// <summary>
		/// Removes all temporary effects when dispell magic is cast
		/// </summary>
		public void RemoveAllTemporaryEffects()
		{
			temporaryEffects.Clear();
		}


		/// <summary>
		/// Removes the specified temporary effect like fire burning health drain
		/// </summary>
		/// <param name="AttributeTypes">Attribute types.</param>
		public void RemoveTemporaryEffect(AttributeTypes attributeType)
		{
			for(int i = (temporaryEffects.Count - 1); i >= 0; i--)
			{
				if(temporaryEffects[i].AttributeType == attributeType)
				{
					temporaryEffects.Remove(temporaryEffects[i]);
				}
			}
			
			CalcTotalAttributes();
		}

		/// <summary>
		/// Removes the temporary effect. Used when the number of rounds have been reduced to 0
		/// </summary>
		private void RemoveTemporaryEffect()
		{
			// Do thi backwards other wise it crashes
			for(int i = (temporaryEffects.Count - 1); i >= 0; i--)
			{
				if(temporaryEffects[i].Rounds == 0)
				{
					temporaryEffects.Remove(temporaryEffects[i]);
                }
			}

			CalcTotalAttributes();
		}

		/// <summary>
		/// Reduces the effects rounds on all temporary effects.
		/// </summary>
		private void ReduceEffectsRounds()
		{
			foreach(Effect currentEffect in temporaryEffects)
			{
				currentEffect.Rounds--;
			}
		}
	}
}

